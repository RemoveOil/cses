    // template<typename T=void>
    // struct minn;
    // template<>
    // struct minn<void> {
    //     template<typename T, typename U>
    //     constexpr auto operator()(T&& lhs, U&& rhs) const
    //     -> decltype(min(std::forward<T>(lhs), std::forward<U>(rhs))) {
    //         return min(std::forward<T>(lhs), std::forward<U>(rhs));
    //     }
    // };

    // template<typename T=void>
    // struct maxx;


    // template<>
    // struct maxx<void> {
    //     template<typename T, typename U>
    //     constexpr auto operator()(T&& lhs, U&& rhs) const
    //     -> decltype(max(std::forward<T>(lhs), std::forward<U>(rhs))) {
    //         return max(std::forward<T>(lhs), std::forward<U>(rhs));
    //     }
    // };


^ structures/segment


template typename vs class
template constraints?
false type / true type
makefile bundling local libs.

advanced algorithms
../euler tour graph...

